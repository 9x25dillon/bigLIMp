opiez – Unified Pipeline

A single repo that wires up:

backend/ – FastAPI API (users + vectorization proxy)

vectorizer/ – Julia MessageVectorizer HTTP microservice

frontend/ – React (Vite) UI to manage users and send motifs

docker-compose.yml – Orchestrates all services

Makefile – Dev ergonomics

Copy this structure as-is to a new repo (or a branch) and docker compose up --build.

Repository Layout

eopiez/
├─ backend/
│  ├─ app/
│  │  ├─ api/
│  │  │  ├─ endpoints/
│  │  │  │  ├─ users.py
│  │  │  │  └─ vectorize.py
│  │  │  └─ routes.py
│  │  ├─ core/
│  │  │  └─ security.py
│  │  ├─ models/
│  │  │  └─ user.py
│  │  ├─ schemas/
│  │  │  └─ user.py
│  │  ├─ database.py
│  │  └─ __init__.py
│  ├─ tests/
│  │  ├─ test_health.py
│  │  └─ test_users.py
│  ├─ requirements.txt
│  └─ main.py
│
├─ vectorizer/  # Julia service
│  ├─ Project.toml
│  ├─ Manifest.toml            # (optional – generated by instantiate)
│  ├─ src/
│  │  ├─ MessageVectorizer.jl
│  │  ├─ types.jl
│  │  ├─ core.jl
│  │  └─ utils.jl
│  ├─ examples/
│  │  └─ message_vectorizer_demo.jl
│  ├─ test/
│  │  └─ runtests.jl
│  ├─ server.jl                 # HTTP microservice
│  ├─ Dockerfile
│  └─ entrypoint.sh
│
├─ frontend/
│  ├─ src/
│  │  ├─ App.jsx
│  │  └─ main.jsx
│  ├─ index.html
│  ├─ package.json
│  └─ vite.config.js
│
├─ docker-compose.yml
├─ Makefile
└─ README.md

backend/main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api.routes import router as api_router
from app.database import engine, Base

# Create DB tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Eopiez API", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(api_router, prefix="/api")

@app.get("/")
async def root():
    return {"message": "Welcome to Eopiez API"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

backend/app/database.py

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./sql_app.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

backend/app/models/user.py

from sqlalchemy import Column, Integer, String
from app.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)

backend/app/schemas/user.py

from pydantic import BaseModel

class UserBase(BaseModel):
    email: str

class UserCreate(UserBase):
    password: str

class User(UserBase):
    id: int
    class Config:
        from_attributes = True

backend/app/core/security.py

import hashlib

def hash_password(password: str) -> str:
    return hashlib.sha256(password.encode()).hexdigest()

backend/app/api/endpoints/users.py

from fastapi import APIRouter, HTTPException
from app.schemas.user import User, UserCreate

router = APIRouter()

# demo in-memory store (swap to DB later)
_users = []

@router.post("/", response_model=User)
async def create_user(user: UserCreate):
    for u in _users:
        if u.email == user.email:
            raise HTTPException(status_code=400, detail="User already exists")
    new_user = User(id=len(_users)+1, email=user.email)
    _users.append(new_user)
    return new_user

@router.get("/{user_id}", response_model=User)
async def get_user(user_id: int):
    for u in _users:
        if u.id == user_id:
            return u
    raise HTTPException(status_code=404, detail="User not found")

@router.get("/", response_model=list[User])
async def list_users():
    return _users

backend/app/api/endpoints/vectorize.py

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import httpx

router = APIRouter()

class MotifToken(BaseModel):
    name: str
    properties: dict
    weight: float
    context: list[str]

class VectorizeRequest(BaseModel):
    motifs: list[MotifToken]
    embedding_dim: int = 64

@router.post("/")
async def vectorize(req: VectorizeRequest):
    # Forward to Julia service
    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            r = await client.post(
                "http://vectorizer:8080/vectorize",
                json={
                    "motifs": [m.dict() for m in req.motifs],
                    "embedding_dim": req.embedding_dim,
                },
            )
            r.raise_for_status()
            return r.json()
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"Vectorizer error: {e}")

backend/app/api/routes.py

from fastapi import APIRouter
from .endpoints import users, vectorize

router = APIRouter()
router.include_router(users.router, prefix="/users", tags=["users"])
router.include_router(vectorize.router, prefix="/vectorize", tags=["message-vectorizer"])

backend/tests/test_health.py

from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_root():
    r = client.get("/")
    assert r.status_code == 200
    assert r.json() == {"message": "Welcome to Eopiez API"}

def test_health():
    r = client.get("/health")
    assert r.status_code == 200
    assert r.json() == {"status": "healthy"}

backend/tests/test_users.py

from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_create_and_get_user():
    r = client.post("/api/users/", json={"email": "test@example.com", "password": "pw"})
    assert r.status_code == 200
    uid = r.json()["id"]
    r2 = client.get(f"/api/users/{uid}")
    assert r2.status_code == 200
    assert r2.json()["email"] == "test@example.com"

backend/requirements.txt

fastapi>=0.110
uvicorn>=0.29
sqlalchemy>=2.0
pydantic>=2
pytest>=8
httpx>=0.27

vectorizer/Project.toml

name = "MessageVectorizer"
uuid = "b3c4b0c1-2a8b-4c3a-9f44-7ad1c2ec9e1f"
authors = ["Randy & Diane"]
version = "0.1.0"

[deps]
Symbolics = "0c5d862f-8b57-4792-8d23-62f2024744c7"
LinearAlgebra = "37e2e46d-f89d-539d-b4ee-838fcccc9c8e"
StatsBase = "2913bbd2-ae8a-5f71-8c99-4fb6c76f3a91"
JSON3 = "0f8b85d8-1172-5c60-9a20-2f6a0a8b4d9c"
Random = "9a3f8284-a2c9-5f02-9a11-845980a1fd5c"
HTTP = "cd3eb016-35fb-5094-929b-558a96fad6f3"

vectorizer/src/MessageVectorizer.jl

module MessageVectorizer

using Symbolics, LinearAlgebra, StatsBase, JSON3, Random

export MotifToken, MessageState, MessageVectorizer
export initialize_vectorizer, create_motif_embedding, add_motif_embedding!
export symbolic_state_compression, compute_entropy, vectorize_message, al_uls_interface

include("types.jl")
include("core.jl")
include("utils.jl")

end

vectorizer/src/types.jl

using Symbolics

struct MotifToken
    name::Symbol
    properties::Dict{Symbol, Any}
    weight::Float64
    context::Vector{Symbol}
end

struct MessageState
    symbolic_expression::Num
    vector_representation::Vector{Float64}
    entropy_score::Float64
    motif_configuration::Dict{Symbol, Float64}
    metadata::Dict{String, Any}
end

mutable struct MessageVectorizer
    motif_embeddings::Dict{Symbol, Vector{Float64}}
    symbolic_variables::Dict{Symbol, Num}
    embedding_dim::Int
    entropy_threshold::Float64
    compression_ratio::Float64
end

vectorizer/src/core.jl

using .MessageVectorizer: MotifToken, MessageState, MessageVectorizer
using Symbolics, LinearAlgebra, Random

function initialize_vectorizer(dim::Int; entropy_threshold=0.5, compression_ratio=0.8)
    @variables s τ μ σ
    sym = Dict{Symbol, Num}(:state=>s, :temporal=>τ, :memory=>μ, :spatial=>σ)
    MessageVectorizer(Dict{Symbol, Vector{Float64}}(), sym, dim, entropy_threshold, compression_ratio)
end

function create_motif_embedding(motif::MotifToken, dim::Int)
    Random.seed!(hash(motif.name))
    v = zeros(Float64, dim)
    base = motif.weight
    for (k, val) in motif.properties
        if val isa Number
            infl = Float64(val) * base
            for i in 1:min(dim, 10)
                v[i] += infl * rand()
            end
        end
    end
    n = norm(v)
    n > 0 ? v ./= n : v
end

function add_motif_embedding!(vec::MessageVectorizer, motif::MotifToken)
    vec.motif_embeddings[motif.name] = create_motif_embedding(motif, vec.embedding_dim)
    nothing
end

function symbolic_state_compression(motifs::Vector{MotifToken}, vec::MessageVectorizer)
    expr = 0
    vars = vec.symbolic_variables
    for m in motifs
        c = m.weight
        if :temporal in m.context
            expr += c * vars[:temporal]
        elseif :memory in m.context
            expr += c * vars[:memory]
        elseif :spatial in m.context
            expr += c * vars[:spatial]
        else
            expr += c * vars[:state]
        end
    end
    expr
end

function compute_entropy(vector::Vector{Float64}, motif_cfg::Dict{Symbol, Float64})
    s = sum(abs.(vector))
    s == 0 && return 0.0
    p = abs.(vector) ./ s
    p = p[p .> 1e-10]
    isempty(p) && return 0.0
    H = -sum(p .* log.(p))
    nm = length(motif_cfg)
    nm > 0 && (H *= log(nm + 1))
    H
end

function vectorize_message(motifs::Vector{MotifToken}, vec::MessageVectorizer)
    cfg = Dict{Symbol, Float64}()
    for m in motifs
        cfg[m.name] = m.weight
    end

    v = zeros(Float64, vec.embedding_dim)
    for m in motifs
        emb = haskey(vec.motif_embeddings, m.name) ? vec.motif_embeddings[m.name] : create_motif_embedding(m, vec.embedding_dim)
        v .+= m.weight .* emb
    end
    n = norm(v)
    n > 0 && (v ./= n)

    expr = symbolic_state_compression(motifs, vec)
    H = compute_entropy(v, cfg)

    meta = Dict(
        "num_motifs" => length(motifs),
        "compression_ratio" => vec.compression_ratio,
        "timestamp" => time(),
        "compressed_size" => length(v),
        "information_density" => H / max(length(v), 1),
    )

    MessageState(expr, v, H, cfg, meta)
end

vectorizer/src/utils.jl

using JSON3, Symbolics
using .MessageVectorizer: MessageState

function al_uls_interface(ms::MessageState)
    out = Dict(
        "symbolic_expression" => string(ms.symbolic_expression),
        "vector_representation" => ms.vector_representation,
        "entropy_score" => ms.entropy_score,
        "motif_configuration" => ms.motif_configuration,
        "metadata" => ms.metadata,
        "compressed_size" => length(ms.vector_representation),
        "information_density" => ms.metadata["information_density"],
    )
    JSON3.write(out)
end

vectorizer/server.jl (HTTP microservice)

import Pkg
Pkg.activate(@__DIR__)
Pkg.instantiate()

using HTTP, JSON3
include("src/MessageVectorizer.jl")
using .MessageVectorizer

const VEC = initialize_vectorizer(64)

function handle(req)
    if req.method == "POST" && HTTP.URIs.path(req.target) == "/vectorize"
        body = String(req.body)
        data = JSON3.read(body)
        dim = get(data, :embedding_dim, 64)
        vec = initialize_vectorizer(dim)
        motifs = MotifToken[]
        for m in data[:motifs]
            push!(motifs, MotifToken(Symbol(m[:name]), Dict{Symbol,Any}((Symbol(k)=>v) for (k,v) in pairs(m[:properties])), Float64(m[:weight]), Symbol.(Vector{String}(m[:context]))))
        end
        # prime embeddings
        for m in motifs
            add_motif_embedding!(vec, m)
        end
        ms = vectorize_message(motifs, vec)
        json = al_uls_interface(ms)
        return HTTP.Response(200, json, ["Content-Type"=>"application/json"])
    end
    return HTTP.Response(404, "Not Found")
end

HTTP.serve(handle, ip"0.0.0.0", 8080)

vectorizer/test/runtests.jl

using Test
include("../src/MessageVectorizer.jl")
using .MessageVectorizer

@testset "MessageVectorizer" begin
    v = initialize_vectorizer(8)
    m1 = MotifToken(:a, Dict(:val=>0.5), 0.7, [:temporal])
    m2 = MotifToken(:b, Dict(:val=>0.2), 0.4, [:memory])
    add_motif_embedding!(v, m1)
    add_motif_embedding!(v, m2)
    ms = vectorize_message([m1,m2], v)
    @test length(ms.vector_representation) == 8
end

vectorizer/examples/message_vectorizer_demo.jl

include("../src/MessageVectorizer.jl")
using .MessageVectorizer

iso = MotifToken(:isolation_time, Dict(:intensity=>0.8, :duration=>24.0), 0.7, [:temporal, :spatial])
dec = MotifToken(:decay_memory, Dict(:decay_rate=>0.3, :memory_strength=>0.6), 0.6, [:memory, :temporal])
vec = initialize_vectorizer(64)
add_motif_embedding!(vec, iso)
add_motif_embedding!(vec, dec)
ms = vectorize_message([iso,dec], vec)
println(al_uls_interface(ms))

vectorizer/Dockerfile

FROM julia:1.9
WORKDIR /app
COPY . .
RUN julia -e 'using Pkg; Pkg.activate("."); Pkg.instantiate()'
EXPOSE 8080
CMD ["julia", "server.jl"]

vectorizer/entrypoint.sh

#!/usr/bin/env bash
set -euo pipefail
julia server.jl

frontend/package.json

{
  "name": "eopiez-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^2.2.0",
    "vite": "^3.2.0"
  }
}

frontend/vite.config.js

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
        secure: false,
      }
    }
  }
})

frontend/src/main.jsx

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)

frontend/src/App.jsx

import React, { useEffect, useState } from 'react'

export default function App(){
  const [users, setUsers] = useState([])
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')

  const [motifs, setMotifs] = useState([
    { name: 'isolation_time', properties: { intensity: 0.8, duration: 24.0 }, weight: 0.7, context: ['temporal','spatial'] },
    { name: 'decay_memory', properties: { decay_rate: 0.3, memory_strength: 0.6 }, weight: 0.6, context: ['memory','temporal'] },
  ])
  const [embeddingDim, setEmbeddingDim] = useState(64)
  const [vectorizeResult, setVectorizeResult] = useState(null)

  useEffect(()=>{ fetchUsers() },[])

  async function fetchUsers(){
    const r = await fetch('/api/users/')
    setUsers(await r.json())
  }

  async function createUser(e){
    e.preventDefault()
    const r = await fetch('/api/users/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ email, password }) })
    const u = await r.json()
    setUsers([...users, u])
    setEmail(''); setPassword('')
  }

  function updateMotif(i, patch){
    setMotifs(motifs.map((m,idx)=> idx===i ? { ...m, ...patch } : m))
  }

  async function runVectorize(){
    const r = await fetch('/api/vectorize/', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ motifs, embedding_dim: embeddingDim }) })
    const data = await r.json()
    setVectorizeResult(data)
  }

  return (
    <div style={{maxWidth:900, margin:'0 auto', padding:24}}>
      <h1 className="text-3xl font-bold mb-6">Eopiez Dashboard</h1>

      <section style={{marginBottom:32}}>
        <h2>User Management</h2>
        <form onSubmit={createUser} style={{display:'flex', gap:12, marginTop:12}}>
          <input required placeholder="email" value={email} onChange={e=>setEmail(e.target.value)} />
          <input required type="password" placeholder="password" value={password} onChange={e=>setPassword(e.target.value)} />
          <button type="submit">Create</button>
        </form>
        <ul style={{marginTop:12}}>
          {users.map(u=> <li key={u.id}>#{u.id} – {u.email}</li>)}
        </ul>
      </section>

      <section>
        <h2>Message Vectorizer (Julia)</h2>
        <div style={{margin:'12px 0'}}>
          <label>Embedding Dim:&nbsp;</label>
          <input type="number" value={embeddingDim} onChange={e=>setEmbeddingDim(parseInt(e.target.value)||64)} />
          <button style={{marginLeft:12}} onClick={runVectorize}>Vectorize</button>
        </div>

        <pre style={{background:'#111', color:'#0f0', padding:12, borderRadius:8, overflow:'auto', maxHeight:300}}>
          {vectorizeResult ? JSON.stringify(vectorizeResult, null, 2) : 'No result yet. Click Vectorize.'}
        </pre>
      </section>
    </div>
  )
}

frontend/index.html

<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eopiez</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

docker-compose.yml

version: '3.8'
services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    volumes:
      - ./backend:/app
    environment:
      - ENVIRONMENT=development
    depends_on:
      - vectorizer

  vectorizer:
    build:
      context: ./vectorizer
      dockerfile: Dockerfile
    ports:
      - "8080:8080"

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules
    environment:
      - CHOKIDAR_USEPOLLING=true
    depends_on:
      - backend

backend/Dockerfile

FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

frontend/Dockerfile

FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "run", "dev"]

Makefile

.PHONY: install dev test build clean up

install:
	cd backend && pip install -r requirements.txt
	cd frontend && npm install

dev:
	(docker compose up --build)

test:
	cd backend && pytest -q
	cd vectorizer && julia test/runtests.jl

build:
	cd frontend && npm run build

clean:
	rm -rf backend/__pycache__ backend/sql_app.db frontend/node_modules frontend/dist

up:
	docker compose up --build

README.md

# Eopiez (FastAPI + React + Julia MessageVectorizer)

## Quickstart

```bash
# from repo root
docker compose up --build

Frontend: http://localhost:3000

Backend:  http://localhost:8000

Julia Vectorizer: http://localhost:8080/vectorize (POST)

Example request (Backend → Julia)

curl -X POST http://localhost:8000/api/vectorize/ \
  -H 'Content-Type: application/json' \
  -d '{
    "embedding_dim": 64,
    "motifs": [
      {"name":"isolation_time","properties":{"intensity":0.8,"duration":24.0},"weight":0.7,"context":["temporal","spatial"]},
      {"name":"decay_memory","properties":{"decay_rate":0.3,"memory_strength":0.6},"weight":0.6,"context":["memory","temporal"]}
    ]
  }'

This returns AL‑ULS‑compatible JSON from the Julia MessageVectorizer.
